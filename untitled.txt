"""
Single-file chatroom inspired by TKC features (for learning and private use).

Features:
- Flask + Flask-SocketIO real-time chat
- Username prompt, join public "Lobby" or create/join rooms
- Message broadcast per room + room list
- Simple moderation: admin login with secret token, /kick and /ban commands
- Rate limiting (per-IP), basic profanity filter, message history persisted to SQLite
- Simple REST endpoints for room list and active users

Security & Legal:
- Educational code to replicate chatroom functionality, not to copy branding or proprietary source.
- For public use, add HTTPS, robust moderation, age-verification, and legal policies.

Run:
1. python3 -m venv venv && source venv/bin/activate
2. pip install flask flask-socketio eventlet sqlalchemy
3. python tkc_clone_chatroom.py
4. Open http://localhost:5000
"""

from flask import Flask, render_template_string, request, jsonify, session
from flask_socketio import SocketIO, emit, join_room, leave_room, disconnect
from datetime import datetime
import sqlite3
import time
import re
import threading

# --- Config ---
SECRET_KEY = 'dev_secret_change_me'
ADMIN_TOKEN = 'admin_secret_change_me'
DB_PATH = 'chat.db'
RATE_LIMIT_SECONDS = 1.0
MAX_MESSAGE_LENGTH = 1000
HISTORY_LIMIT = 200
PROFANITY_WORDS = {'badword'}

# --- Flask app & socket ---
app = Flask(__name__)
app.config['SECRET_KEY'] = SECRET_KEY
socketio = SocketIO(app, cors_allowed_origins='*', async_mode='eventlet')

# --- SQLite helpers ---
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS messages (id INTEGER PRIMARY KEY AUTOINCREMENT, room TEXT, username TEXT, text TEXT, ts DATETIME)''')
    c.execute('''CREATE TABLE IF NOT EXISTS bans (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT, ip TEXT, reason TEXT, banned_at DATETIME)''')
    conn.commit()
    conn.close()

def save_message(room, username, text):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('INSERT INTO messages (room, username, text, ts) VALUES (?, ?, ?, ?)',
              (room, username, text, datetime.utcnow()))
    conn.commit()
    conn.close()

def get_history(room, limit=HISTORY_LIMIT):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT username, text, ts FROM messages WHERE room=? ORDER BY id DESC LIMIT ?',
              (room, limit))
    rows = c.fetchall()
    conn.close()
    return [{'username': r[0], 'text': r[1], 'ts': r[2]} for r in reversed(rows)]

def add_ban(username=None, ip=None, reason=''):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('INSERT INTO bans (username, ip, reason, banned_at) VALUES (?, ?, ?, ?)',
              (username, ip, reason, datetime.utcnow()))
    conn.commit()
    conn.close()

def check_ban(username=None, ip=None):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    if username:
        c.execute('SELECT 1 FROM bans WHERE username=? LIMIT 1', (username,))
        if c.fetchone():
            conn.close()
            return True
    if ip:
        c.execute('SELECT 1 FROM bans WHERE ip=? LIMIT 1', (ip,))
        if c.fetchone():
            conn.close()
            return True
    conn.close()
    return False

# --- In-memory state ---
rooms = {'Lobby': set()}
user_last_msg = {}
user_meta = {}

# --- Profanity filter ---
profanity_re = None
if PROFANITY_WORDS:
    profanity_re = re.compile(r"\b(?:" + "|".join(re.escape(w) for w in PROFANITY_WORDS) + r")\b", re.IGNORECASE)

# --- HTML template ---
INDEX_HTML = """<!doctype html>
<html>
<head><meta charset="utf-8" /><title>Chatroom</title>
<style>
body { font-family: Arial; margin:0; padding:0; display:flex; height:100vh }
#sidebar { width:240px; border-right:1px solid #ddd; padding:10px }
#main { flex:1; display:flex; flex-direction:column }
#messages { flex:1; padding:10px; overflow:auto }
#input { padding:10px; border-top:1px solid #ddd }
.msg { margin-bottom:8px }
.meta { color:#666; font-size:0.9em }
.system { color:#b00 }
.room { cursor:pointer }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.min.js"></script>
</head>
<body>
<div id="sidebar">
<h3>Rooms</h3>
<div id="rooms"></div>
<hr>
<label>Username: <input id="username"/></label><br>
<label>Admin token: <input id="admintoken" placeholder="optional"/></label><br>
<button id="joinBtn">Join</button>
<hr>
<strong>Active Users</strong>
<ul id="users"></ul>
</div>
<div id="main">
<div id="messages"></div>
<div id="input">
<input id="text" style="width:80%" placeholder="Type /help for commands"/>
<button id="send">Send</button>
</div>
</div>
<script>
let socket; let currentRoom='Lobby'; let username=''; let isAdmin=false;
function addMessage(html){const d=document.createElement('div');d.className='msg';d.innerHTML=html;document.getElementById('messages').appendChild(d);document.getElementById('messages').scrollTop=document.getElementById('messages').scrollHeight;}
async function fetchRooms(){const res=await fetch('/rooms');const j=await res.json();const container=document.getElementById('rooms');container.innerHTML='';j.rooms.forEach(r=>{const el=document.createElement('div');el.textContent=r+' ('+j.counts[r]+')';el.className='room';el.onclick=()=>{if(username) joinRoom(r)};container.appendChild(el);});}
function joinRoom(room){socket.emit('join',{room});currentRoom=room;document.getElementById('messages').innerHTML='';addMessage('<div class="system">Joined '+room+'</div>');}
function bindUI(){document.getElementById('joinBtn').onclick=()=>{username=document.getElementById('username').value.trim();const token=document.getElementById('admintoken').value.trim();if(!username) return alert('Enter username');socket=io();socket.on('connect',()=>{socket.emit('introduce',{username,token});});socket.on('message',m=>{addMessage('<span class="meta">['+m.ts+'] <b>'+m.username+':</b></span> '+m.text);});socket.on('system',m=>{addMessage('<span class="system">'+m+'</span>');});socket.on('history',hist=>{hist.forEach(h=>addMessage('<span class="meta">['+h.ts+'] <b>'+h.username+':</b></span> '+h.text));});socket.on('user_list',list=>{const ul=document.getElementById('users');ul.innerHTML='';list.forEach(u=>{const li=document.createElement('li');li.textContent=u;ul.appendChild(li);});});fetchRooms();};document.getElementById('send').onclick=()=>{sendText();};document.getElementById('text').addEventListener('keydown',ev=>{if(ev.key==='Enter') sendText();});}
function sendText(){const t=document.getElementById('text').value.trim();if(!t)return;if(t.startsWith('/')){socket.emit('command',{cmd:t});}else{socket.emit('chat',{room:currentRoom,text:t});}document.getElementById('text').value='';}
bindUI();setInterval(fetchRooms,5000);
</script>
</body></html>
"""

# --- Routes ---
@app.route('/')
def index():
    return render_template_string(INDEX_HTML)

@app.route('/rooms')
def list_rooms():
    counts = {r: len(users) for r, users in rooms.items()}
    return jsonify({'rooms': list(rooms.keys()), 'counts': counts})

# --- Socket handlers ---
@socketio.on('connect')
def handle_connect():
    sid = request.sid
    ip = request.remote_addr
    user_meta[sid] = {'username': None, 'room': None, 'ip': ip, 'is_admin': False}
    emit('system', 'Connected. Please introduce yourself with a username.')

@socketio.on('disconnect')
def handle_disconnect():
    sid = request.sid
    meta = user_meta.get(sid)
    if meta:
        uname = meta.get('username')
        room = meta.get('room')
        if room and uname and uname in rooms.get(room, set()):
            rooms[room].remove(uname)
            socketio.emit('user_list', list(rooms[room]), to=room)
        user_meta.pop(sid, None)

# --- Background cleanup ---
def room_cleanup_loop():
    while True:
        to_delete = [r for r,u in rooms.items() if len(u)==0 and r!='Lobby']
        for r in to_delete: rooms.pop(r, None)
        time.sleep(30)

# --- Start-up ---
if __name__ == '__main__':
    init_db()
    t = threading.Thread(target=room_cleanup_loop, daemon=True)
    t.start()
    print('Starting chat server on http://0.0.0.0:5000')
    socketio.run(app, host='0.0.0.0', port=5000)